{"version":3,"file":"168.2734d54f.iframe.bundle.js","mappings":";;AAqBA;AAIA;AAWA;AAWA;AAIA;AAmBA;AAGA;AAVA;AAEA;AC7BA;AClCA;AC8BA;AAGA","sources":["webpack://@muban/hooks/./node_modules/@muban/muban/dist/esm/lib/props/property-sources/convertSourceValue.js","webpack://@muban/hooks/./node_modules/@muban/muban/dist/esm/lib/props/property-sources/createClassListPropertySource.js","webpack://@muban/hooks/./node_modules/@muban/muban/dist/esm/lib/props/property-sources/createDataAttributePropertySource.js","webpack://@muban/hooks/./node_modules/@muban/storybook/dist/esm/client/preview/utils.js"],"sourcesContent":["import parseJson from 'json-parse-better-errors';\nimport dedent from 'ts-dedent';\nexport function convertSourceValue(propInfo, value) {\n    switch (propInfo.type) {\n        // eslint-disable-next-line default-case-last\n        default:\n        case String: {\n            return value;\n        }\n        case Number: {\n            if (!value) {\n                return undefined;\n            }\n            // TODO, (how) should we support integers?\n            //  maybe allow convertors as well, and use type to set some default convertors?\n            //  or are validators enough?\n            const converted = parseFloat(value);\n            // eslint-disable-next-line no-restricted-globals\n            if (isNaN(converted) || !isFinite(converted)) {\n                // eslint-disable-next-line no-console\n                console.warn(dedent `The property \"${propInfo.name}\" of type \"${propInfo.type.name}\" has possible invalid value.\n                Received \"${value}\", parsed into \"${converted}\".\n                Returning \"undefined\"`);\n                return undefined;\n            }\n            return converted;\n        }\n        case Boolean: {\n            if (value === '') {\n                // Developers might expect boolean attributes to work:\n                // https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes\n                // but we choose to be explicit to make this easier to implement in the CMS\n                // eslint-disable-next-line no-console\n                console.warn(dedent `The property \"${propInfo.name}\" of type \"${propInfo.type.name}\" has an empty value, so is set to \"false\".\n                Please provide explicit \"true\" or \"false\" as a value for booleans.`);\n            }\n            return value.toLowerCase() === 'true';\n        }\n        case Date: {\n            if (!value) {\n                return undefined;\n            }\n            const converted = new Date(value);\n            // eslint-disable-next-line no-restricted-globals\n            if (isNaN(converted.getTime())) {\n                // eslint-disable-next-line no-console\n                console.warn(dedent `The property \"${propInfo.name}\" of type \"${propInfo.type.name}\" has possible invalid value.\n                Received \"${value}\", parsed into \"${converted}\".\n                Returning \"undefined\".`);\n                return undefined;\n            }\n            return converted;\n        }\n        case Array:\n        case Object: {\n            if (!value) {\n                return undefined;\n            }\n            try {\n                const converted = parseJson(value);\n                if (propInfo.type === Array && !Array.isArray(converted)) {\n                    // eslint-disable-next-line no-console\n                    console.warn(dedent `The property \"${propInfo.name}\" of type \"${propInfo.type.name}\" is not an Array.\n                  Received \"${value}\", parsed into \"${converted}.\n                  Returning \"undefined\"\"`);\n                    return [];\n                }\n                if (propInfo.type === Object && !(converted instanceof Object)) {\n                    // eslint-disable-next-line no-console\n                    console.warn(dedent `The property \"${propInfo.name}\" of type \"${propInfo.type.name}\" is not an Object.\n                  Received \"${value}\", parsed into \"${converted}.\n                  Returning \"undefined\"\"`);\n                }\n                return converted;\n            }\n            catch (error) {\n                // eslint-disable-next-line no-console\n                console.error(error);\n                return undefined;\n            }\n        }\n    }\n}\n","import { camelCase, paramCase } from 'change-case';\nimport dedent from 'ts-dedent';\nexport function createClassListPropertySource() {\n    return () => ({\n        sourceName: 'css',\n        hasProp: (propInfo) => \n        // by default, we only support booleans\n        (propInfo.source.type === undefined && propInfo.type === Boolean) ||\n            // but if explicit, we support other types as well\n            (propInfo.source.type === 'css' && Boolean(propInfo.source.target)),\n        getProp: (propInfo) => {\n            var _a;\n            const target = propInfo.source.target;\n            // in case of boolean, check for existence\n            if (propInfo.type === Boolean) {\n                const hasValue = Boolean(target.classList.contains(propInfo.source.name) ||\n                    target.classList.contains(camelCase(propInfo.source.name)) ||\n                    target.classList.contains(paramCase(propInfo.source.name)));\n                // only return false from missing value if this source is used explicitly\n                // or if value is found\n                if (propInfo.source.type === 'css' || hasValue) {\n                    return hasValue;\n                }\n                // otherwise return undefined to fallback to the default\n                return undefined;\n            }\n            // in case of string, check for cssPredicate existence\n            if (propInfo.type === String) {\n                if (!((_a = propInfo.source.options) === null || _a === void 0 ? void 0 : _a.cssPredicate)) {\n                    // eslint-disable-next-line no-console\n                    console.warn(dedent `The property \"${propInfo.name}\" of type \"${propInfo.type.name}\" requires the use of \"source.options.cssPredicate\" to be set.\n              Returning \"undefined\".`);\n                    return undefined;\n                }\n                return Array.from(target.classList).find((className) => { var _a; return (_a = propInfo.source.options) === null || _a === void 0 ? void 0 : _a.cssPredicate(className); });\n            }\n            if (propInfo.type === Array) {\n                return Array.from(target.classList);\n            }\n            if (propInfo.type === Object) {\n                return Array.from(target.classList).reduce((accumulator, className) => (Object.assign(Object.assign({}, accumulator), { [className]: true })), {});\n            }\n            // eslint-disable-next-line no-console\n            console.warn(dedent `The property \"${propInfo.name}\" of type \"${propInfo.type.name}\" does not support the \"css\" source.\n              Returning \"undefined\".`);\n            return undefined;\n        },\n    });\n}\n","import { convertSourceValue } from './convertSourceValue';\nexport function createDataAttributePropertySource() {\n    return () => ({\n        sourceName: 'data',\n        hasProp: (propInfo) => Boolean(propInfo.source.target &&\n            propInfo.type !== Function &&\n            propInfo.source.name in propInfo.source.target.dataset),\n        getProp: (propInfo) => {\n            var _a;\n            let value;\n            const rawValue = propInfo.type !== Function\n                ? (_a = propInfo.source.target.dataset[propInfo.source.name]) !== null && _a !== void 0 ? _a : undefined\n                : undefined;\n            if (rawValue !== undefined) {\n                value = convertSourceValue(propInfo, rawValue);\n            }\n            else if (propInfo.type === Boolean) {\n                // TODO: output warning about undefined booleans once we document\n                //  how these should behave for all type of sources\n                // eslint-disable-next-line no-console\n                console.warn();\n            }\n            return value;\n        },\n    });\n}\n","/* eslint-disable unicorn/prevent-abbreviations */\nimport { html, unsafeHTML } from '@muban/template';\n/**\n * Helper function for component decorators that:\n * - allows you to pass only a component or template, where this function will fill in the other part\n * - already apply the template props and pass the rendered child template\n */\nexport function createDecoratorComponent(createDecoratorFn) {\n    return (story, context) => {\n        var _a, _b, _c, _d, _e;\n        const storyComponent = story();\n        const storyTemplateResult = storyComponent.template((_a = context.args) !== null && _a !== void 0 ? _a : {});\n        const decoratorComponent = createDecoratorFn({\n            story,\n            context,\n            // TODO: document that not all stories have components\n            component: storyComponent.component,\n            template: storyTemplateResult,\n        });\n        // merge appComponents to pass \"up\", so story renderer can access it\n        const appComponents = [\n            ...((_b = decoratorComponent.appComponents) !== null && _b !== void 0 ? _b : []),\n            ...((_c = storyComponent.appComponents) !== null && _c !== void 0 ? _c : []),\n        ];\n        if (!decoratorComponent.component && !decoratorComponent.template) {\n            return Object.assign(Object.assign({}, storyComponent), { appComponents });\n        }\n        const component = (_d = decoratorComponent.component) !== null && _d !== void 0 ? _d : storyComponent.component;\n        let template = (_e = decoratorComponent.template) !== null && _e !== void 0 ? _e : storyComponent.template;\n        // create dummy template attaching to the decoratorComponent so it gets initialized\n        if (!decoratorComponent.template && decoratorComponent.component) {\n            template = () => html `<div data-component=${decoratorComponent.component.displayName}>\n          ${unsafeHTML(storyTemplateResult.toString())}\n        </div>`;\n        }\n        return {\n            appComponents,\n            component,\n            template,\n        };\n    };\n}\n"],"names":[],"sourceRoot":""}